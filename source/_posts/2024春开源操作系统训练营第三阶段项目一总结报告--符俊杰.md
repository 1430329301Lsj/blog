---
title: '2024春开源操作系统训练营第三阶段项目一总结报告--符俊杰'
date: 2024-06-29 4:17:48
categories:
    - report
tags:
    - author: xhyf77
    - Spring Camp 2024
---


### 第三阶段总结
#### 前期实验
第三阶段前期老师带领我们基于Arceos做了两周的实验，这两周实验比较有难度的是练习2：支持HashMap数据类型。其他的都比较简单，且Arceos源码本身看起来也比较易懂，因此我用大概一周就全部完成了。

#### 进入真正的项目阶段
##### musl入手
由于musl编译出来的app系统调用要比glibc简单的多且少得多，因此我先尝试支持用musl-gcc编译的hello_world程序。
经历大概如下：
- 支持加载hello_world.bin程序并执行
- 支持对elf的解析
- 支持对hello_world.elf程序的执行

#### 支持glibc
要支持glibc要实现和空实现一些syscall

#### 坑点总结
- 在支持glibc的时候由于glibc调用了一些task相关的syscall，需要拿到当前的task_sched_info，但是每次都拿不到（None），就很奇怪，明明也进行了task::init()，为什么拿不到呢？后面一直跟踪拿task_sched_info的源码才发现是通过读gp寄存器拿的，存也是把task_sched_info的地址存在gp寄存器上。然后我就怀疑gp寄存器在app运行时被改变了，于是查看qemu.log，果然一开始就动了gp寄存器。于是我采用一个全局静态变量来存当前的task_sched_info，这样就可以顺利拿到了。
- 一开始没有清理.bss，导致运行时各种奇怪的问题。其实一开始没清理.bss是因为我在做payload的时候是创建了一个32M的空文件（全0），然后把app.elf文件写进去，我想写的时候是全0，我就不用清理了吧，但在debug的时候发现利用lkmodel下的elf crate来对app.elf进行解析的时候竟然把.bss那块儿区域写了一些数据，就因为偷了个懒，导致又浪费一大把时间debug。
- 在支持vfork时，vfork的子进程由于要copy父进程的进入trap_handler时的寄存器信息以正确返回。在子进程返回时发现其trap上下文的sepc寄存器一直是0，且其他寄存器的值也不正常，经过调试发现是copy父进程的trap上下文时出现了问题，最后发现问题如下：
pt_regs_addr()函数（即拿到trap上下地址的函数）原来是
```
    pub fn pt_regs_addr(&self) -> usize {
        self.kstack.as_ref().unwrap().top() - align_down(TRAPFRAME_SIZE, STACK_ALIGN)
    }
```
但是由于align_down导致减去的值不是TRAPFRAME_SIZE
但在汇编中却是用self.kstack.as_ref().unwrap().top() 直接减去TRAPFRAME_SIZE
如下：
```
.Ltrap_entry_s:
    addi    sp, sp, -{trapframe_size}
    SAVE_REGS 0
    mv      a0, sp
    auipc   a1, 0          # Load the upper 20 bits of the PC into a1
    addi    a1, a1, 12
    call    riscv_trap_handler
    RESTORE_REGS 0
    sret

.Ltrap_entry_u:
    addi    sp, sp, -{trapframe_size}
    SAVE_REGS 1
    mv      a0, sp
    li      a1, 1
    call    riscv_trap_handler
    addi    t0, sp, {trapframe_size}    // put supervisor sp to scratch
    csrw    sscratch, t0
    RESTORE_REGS 1
    sret
```
因此在rust中是用pt_regs_addr()获取trap_frame地址然后进行读写操作是和汇编里面的存储位置不匹配。
- 注意给task.mm复制可能导致原来task.mm指向的页面被回收
- 不知道是不是因为静态链接的原因，我这边argc,argv,env在栈上的排布和ppt不一样，用ppt的方式排布app拿不到argv
下面是我在其他地方看到的另一种排布方式
```
高地址
--
  0
  ...
  envp[1]
  envp[0]
  0
  ...
  argv[1]
  argv[0]
  argc
--
低地址
```
#### 总结
这一个月的项目实习使我debug能力又有了提升同时更加深刻的理解了musl-gcc,glib-gcc的区别，同时也更加深刻的了解了Unikernel。同时也跟同学老师们学到了很多东西。