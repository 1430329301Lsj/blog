---
title: 2024开源操作系统训练营第一阶段总结-dmw
date: 2024-04-28 11:19:42
tags:
    - author:<dream233333>
    - repo:<https://github.com/LearningOS/rust-rustlings-2024-spring-dream233333>

---

​        一转眼110道题目已经结束，100道语法练习和10道算法题下来让我受益匪浅。对于此前只有一些c语言和python语言基础的我来说，难度比较大，很多概念还是理解不清楚，算法也是临时学的，可谓非常艰难。不过对rust的学习对我的编程思维很有启发，也是我第一次直接接触到并发和所有权的概念。

​         此前编程单纯考虑能跑就行，但实际上是不够的，作为信息安全专业的人这几年写代码从不考虑安全实在是惭愧，所幸在学生时期接触到了rust,不至于在未来项目出现一些令人痛苦的问题后惊觉对底层知识的忽视。随着学习的深入，越发理解底层知识对编程的重要性，当然这也是我参加2024oscamp的原因。不罗嗦了，那么作为简单的记录，先总结一下吧！

> ：Rust 中有两种字符串类型：`String` 和 `&str`。
>
> `String` 被存储为由字节组成的 vector（`Vec<u8>`），是一个有效的 UTF-8 序列。`String` 是堆分配的，可增长的，且不是零结尾的。`&str` 是一个总是指向有效 UTF-8 序列的切片（`&[u8]`），并可用来查看 `String` 的内容，就如同 `&[T]` 是 `Vec<T>` 的全部或部分引用。
>
> 自定义的错误特征，错误之间很可能会存在上下级关系，例如标准库中的 `std::io::Error `和 `std::error::Error`，前者是 IO 相关的错误结构体，后者是一个最最通用的标准错误特征，同时前者实现了后者，因此 `std::io::Error` 可以转换为 `std:error::Error`。
>
> 在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。
>
> 生命周期标注并不会改变任何引用的实际作用域 
>
> 标记的生命周期只是为了取悦编译器，让编译器不要难为我们
>
> ​																					——RUST语言圣经
>
> 
>
> 生命周期注释有一个特别的：**'static** 。所有用双引号包括的字符串常量所代表的精确数据类型都是 &'static str ，'static 所表示的生命周期从程序运行开始到程序运行结束。
>
> `map` 方法是一个迭代者适配器，它最大的好处不仅在于可以就地实现迭代器中元素的处理，还在于可以捕获环境值。它是惰性的，不产生任何行为，因此我们还需要一个消费者适配器进行收尾：
>
> 消费者适配器是消费掉迭代器，然后返回一个值。那么迭代器适配器，顾名思义，会返回一个新的迭代器，这是实现链式方法调用的关键：`v.iter().map().filter()...`。
>
> > `filter()` 的闭包需要用一个引用，并且许多迭代器迭代引用，所以这可能导致混乱的情况，其中闭包的类型是双引用：通常在参数上使用解构来去掉一个
> >
> > ```rust
> > let mut iter = a.iter().filter(|x| **x > 1);
> > let mut iter = a.iter().filter(|&x| *x > 1);
> > ```
>
> > *flat_map()*
> >
> > map 适配器非常有用，但仅当闭包参数产生值时才使用。 如果它产生一个迭代器，则存在一个额外的间接层。 flat_map() 将自行删除这个额外的层。
>
> > **特性**（trait）概念接近于 Java 中的接口（Interface），但两者不完全相同。特性与接口相同的地方在于它们都是一种行为规范，可以用于标识哪些类有哪些方法。
> >
> > 特性在 Rust 中用 trait 表示：
> >
> > 格式是:
>
> > ```
> > impl <特性名> for <所实现的类型名>
> > ```
>
> > Rust 同一个类可以实现多个特性，每个 impl 块只能实现一个。
>
> - `Box<T>`，可以将值分配到堆上
> - `Rc<T>`，引用计数类型，允许多所有权存在
> - `Ref<T>` 和 `RefMut<T>`，允许将借用规则检查从编译期移动到运行期进行.写链表的时候再回忆一下……
>
> - AsRef 是一个 trait（特质），用于将一个类型转换为另一种类型的引用。
> - AsRef 的作用是允许我们以统一的方式处理不同类型之间的转换。通过实现 AsRef trait，我们可以定义一个类型转换函数，该函数将一个类型转换为另一个类型的引用。
> - 如果我们有一个类型 T，并且希望将其转换为类型 U 的引用，我们可以实现 AsRef `<U>` trait 来完成这个转换。在实现中，我们需要提供一个名为 as_ref 的方法，该方法返回类型 &U。这样，我们就可以使用 as_ref 方法来将 T 转换为 U 的引用。
>
> fn num_sq<T: AsMut<u32>>(arg: &mut T)
>
>  **AsMut< >**可变引用。其他同上
>
> 
>
> > Rust 宏（Macros）是一种在编译时生成代码的强大工具，它允许你在编写代码时创建自定义语法扩展。
> >
> > ```rust
> > macro_rules! my_macro {
> >  // 模式匹配和展开
> >  ($arg:expr) => {
> >      // 生成的代码
> >      // 使用 $arg 来代替匹配到的表达式
> >  };
> > }
> > ```
>
> 还有很多没写，笔记记在其他地方了，不过太零散了，有空整理一下。

