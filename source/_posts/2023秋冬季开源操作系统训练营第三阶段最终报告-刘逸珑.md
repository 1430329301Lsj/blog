---
title: 2023秋冬季开源操作系统训练营第三阶段最终报告-刘逸珑
date: 2023-12-02 23:52:30
categories:
    - oscamp 2023fall arceos unikernel
tags: 
    - author:jackyliu16
    - 2023秋冬季开源操作系统训练营
    - 第三阶段总结报告
---

本次主要采用是通过类似于在GNU/LD链接器的方式来完成整个任务。主要的参照依据是csapp中有关链接的相关说明。
目前的实际完成进度在于完成了符号的解析。但是后面的重定包括段重定位以及符号的重定位，目前还没有完成。

目前操作上来说，对于后续任务影响最大的内容在于之前任务的不正确完成，包括但不限于之前任务中埋藏的坑，比如说文件不能正确识别，将 1B 认定成为 一个16进制数而导致对于加载的文件中的align的错误判断，甚至还将用于解释rust内部结构体的自动align用于解释这里所出现的人为导致的align。

目前的完成情况如下：

直接通过 shdr.e_type 实现对于符号的定位，根据CSAPP的说明，使用多个集合对于符号进行处理，实现符号匹配效果

```rust
match elf_file.ehdr.e_type {
            ET_REL => { println!("Detect ET_REL");
                let (symtabs, strtabs) = elf_file
                    .symbol_table()
                    .expect("Failure when parse symtabs from elf file")
                    .expect("Failure when parse symtabs from elf file");

                for sym in symtabs.iter() {
                    // Because the corresponding values are not publicly available, we have to gain all of it
                    let sym_name = strtabs.get(sym.st_name as usize).expect("Failure to get section name");
                    if sym_name == "" { continue; }

                    let elf_file = ElfBytes::<AnyEndian>::minimal_parse(read_only_elf).expect("Could Not Load ELF File From MEM");
                    if sym.is_undefined() {
                        info!("U: push {sym_name}");
                        info!("sym: {:?}", sym);
                        U.push((String::from(sym_name), sym.clone(), elf_file))
                    } else {
                        info!("D: push {sym_name}");
                        D.push((sym, elf_file));
                    }  
                }
                let elf_file = ElfBytes::<AnyEndian>::minimal_parse(read_only_elf).expect("Could Not Load ELF File From MEM");
                elfs.push(elf_file);
            },
            ET_DYN => { println!("Detect ET_DYN");
                // test each elf file if it contains a unresolved symbols
                let mut remove = Vec::new();
                for i in 0..U.len() {
                    let sym_name = &U.get(i).unwrap();
                    if let Some(obj_sym) = elf_file_contains_symbol(&elf_file, sym_name.0.clone()) {
                        // detect symbol sucessed
                        info!("detect symbol {} sucessed", sym_name.0);
                        let elf_file = ElfBytes::<AnyEndian>::minimal_parse(read_only_elf).expect("Could Not Load ELF File From MEM");
                        elfs.push(elf_file);
                        remove.push(i);
                        let elf_file = ElfBytes::<AnyEndian>::minimal_parse(read_only_elf).expect("Could Not Load ELF File From MEM");
                        info!("sym: {:?}", obj_sym);
                        info!("sym: {:p}", &obj_sym);
                        D.push((obj_sym, elf_file));
                    }
                }
                for idx in (0..remove.len()).rev() {
                    U.remove(idx);
                }
            },
            ET_EXEC | ET_CORE | ET_LOOS | ET_HIOS | _ => {
                error!("Input a file with unsupported type: {}", elf_file.ehdr.e_type);
            },
        }
```

/// BLUE PRINT
/// 
/// 1. LOAD APPLICATION
/// 2. SYMBOL RESOLUTION: make sure all symbol has been meet.
/// 3. RELOCATION:
///     [1] RELOCATION SECTION: 
///         merges all sections of the same type into a new aggregate section of the same typecombine 
///         BC we only need  SHT_PROGBITS thus not care about others (copy).
///     [2] RELOCATE SYMBOL REFERENCES IN SECTIONS: 
///         Modify references to each symbol in code and data sections so that they point to the correct run-time address

半成品：

```rust
   for i in 0..app_num {
        let i = i as usize; println!("===================="); println!("= START OF APP {i} size: {} =", apps[i as usize].size); println!("====================");

        let read_only_elf = unsafe { core::slice::from_raw_parts(apps[i].start_addr, apps[i].size) };
        let elf_file = ElfBytes::<AnyEndian>::minimal_parse(read_only_elf).expect("Could Not Load ELF File From MEM");

        // SYMBOL RESOLUTION
        match elf_file.ehdr.e_type {
            ET_REL => { println!("Detect ET_REL");
                let (symtabs, strtabs) = elf_file
                    .symbol_table()
                    .expect("Failure when parse symtabs from elf file")
                    .expect("Failure when parse symtabs from elf file");

                for sym in symtabs.iter() {
                    // Because the corresponding values are not publicly available, we have to gain all of it
                    let sym_name = strtabs.get(sym.st_name as usize).expect("Failure to get section name");
                    if sym_name == "" { continue; }

                    let elf_file = ElfBytes::<AnyEndian>::minimal_parse(read_only_elf).expect("Could Not Load ELF File From MEM");
                    if sym.is_undefined() {
                        info!("U: push {sym_name}");
                        info!("sym: {:?}", sym);
                        U.push((String::from(sym_name), sym.clone(), elf_file))
                    } else {
                        info!("D: push {sym_name}");
                        D.push((sym, elf_file));
                    }  
                }
                let elf_file = ElfBytes::<AnyEndian>::minimal_parse(read_only_elf).expect("Could Not Load ELF File From MEM");
                elfs.push(elf_file);
            },
            ET_DYN => { println!("Detect ET_DYN");
                // test each elf file if it contains a unresolved symbols
                let mut remove = Vec::new();
                for i in 0..U.len() {
                    let sym_name = &U.get(i).unwrap();
                    if let Some(obj_sym) = elf_file_contains_symbol(&elf_file, sym_name.0.clone()) {
                        // detect symbol sucessed
                        info!("detect symbol {} sucessed", sym_name.0);
                        let elf_file = ElfBytes::<AnyEndian>::minimal_parse(read_only_elf).expect("Could Not Load ELF File From MEM");
                        elfs.push(elf_file);
                        remove.push(i);
                        let elf_file = ElfBytes::<AnyEndian>::minimal_parse(read_only_elf).expect("Could Not Load ELF File From MEM");
                        info!("sym: {:?}", obj_sym);
                        info!("sym: {:p}", &obj_sym);
                        D.push((obj_sym, elf_file));
                    }
                }
                for idx in (0..remove.len()).rev() {
                    U.remove(idx);
                }
            },
            ET_EXEC | ET_CORE | ET_LOOS | ET_HIOS | _ => {
                error!("Input a file with unsupported type: {}", elf_file.ehdr.e_type);
            },
        }
    }

    // RELOCATION[1]: RELOCATE SECTION AND SYMBOL DEFINITIONS:
    //  NOTE: Currently, Seems there is no ways to merge section in diff elf_file and same name into one, we have to use this ways to gain it.
    //  Maybe in future it could be replace by some automatic Vec or others, but not now.
    let mut sec_text: Vec<(&ElfBytes<AnyEndian>, usize)> = Vec::new();
    let mut sec_data: Vec<(&ElfBytes<AnyEndian>, usize)> = Vec::new();

    /// pointer to the Last unallocated run-time address 
    let mut unallocated_pointer = LOAD_START;
    /// a map between (Elf, Section) to run-time address
    let mut section_start_addrs: Vec<(&ElfBytes<AnyEndian>, usize)> = Vec::new();

    // just not case about if we should merge segment with same name in diff elf_file
    for i in 0..app_num {
        let i = i as usize;
        let elf_file = &elfs[i];

        // if sh_type == SHT_PROGBITS then load in mem (both .data and .text in)
        if let Some(shdrs) = elf_file.section_headers() {
            for shdr in shdrs {
                match shdr.sh_type {
                    SHT_PROGBITS => { // LOAD IN MEM
                        let read_only_areas = unsafe { core::slice::from_raw_parts(apps[i].start_addr.offset(shdr.sh_offset as isize), shdr.sh_size as usize)};
                        let load_areas = unsafe { core::slice::from_raw_parts_mut(unallocated_pointer as *mut u8, shdr.sh_size as usize)};
                        load_areas.copy_from_slice(read_only_areas);
                        // for b in load_areas { println!("{:02x}", b); }
                        let elf_file = &elfs[i];
                        section_start_addrs.push((elf_file, shdr.sh_name as usize));
                        unallocated_pointer += shdr.sh_size as usize;
                    },
                    _ => { trace!("Skip Section {} from loading", shdr.sh_type) }
                }
            }
        }
    }

    // 2. RELOCATE SYMBOL REFERENCES IN SECTIONS
    for i in 0..app_num {
        let i = i as usize;
        // relocation

        let elf_file = &elfs[i];

        let (shdrs_opt, strtab_opt) = elf_file 
            .section_headers_with_strtab()
            .expect("shdrs offsets should be valid");
        let (shdrs, strtab) = (
            shdrs_opt.expect("Should have shdrs"),
            strtab_opt.expect("Should have strtab")
        );


        for shdr in shdrs.iter() {
            match shdr.sh_type {
                SHT_REL | SHT_RELA => { // Relocate Symbol References in sections
                    if let Ok(iter_rel) = elf_file.section_data_as_rels(&shdr) {
                        for rel in iter_rel {
                            debug!("REL");
                        }
                    }

                    if let Ok(iter_rela) = elf_file.section_data_as_relas(&shdr) {
                        info!("rela: {:?}", iter_rela);
                        for rela in iter_rela {
                            debug!("RELA");
                            trace!("{:?}", rela);
                            info!("shdr.sh_offset: {}", shdr.sh_offset);
                            match rela.r_type {
                                R_RISCV_64 => { info!("R_RISCV_64"); },                 // 2
                                R_RISCV_RELATIVE => { info!("R_RISCV_RELATIVE"); },     // 3
                                R_RISCV_JUMP_SLOT => { info!("R_RISCV_JUMP_SLOT"); },   // 5
                                R_RISCV_CALL => { info!("R_RISCV_CALL"); },             // 18
                                _ => { debug!("UNKNOWN RELA TYPE: {}", rela.r_type); }
                            }
                        }
                    }
                },
                _ => {
                    trace!("SECTION TYPE {} NOT DETECT", shdr.sh_type);
                }
            }
        }
    }

```